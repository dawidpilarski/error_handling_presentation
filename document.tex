\documentclass[10pt,a4paper]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{pifont}
\usepackage[cache=false]{minted}

\setminted{fontsize=\footnotesize}

\date{}
\author{Dawid Pilarski}

\title{Error handling in C++}


\begin{document}


\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\tableofcontents
\end{frame}

\section{Current state of error handling}
\begin{frame}{Built-in error handling mechanisms}
	
	There exist two common strategies for error handling:
	\begin{itemize}
		\item error codes
		\item exceptions
	\end{itemize}

\end{frame}

\subsection{Error codes description}
\begin{frame}[fragile]{Error codes - example fopen}
	\begin{minted}{c++}
/* fopen example */
#include <stdio.h>
int main ()
{
  FILE * pFile;
  pFile = fopen ("myfile.txt","w");
  if (pFile!=NULL)
  {
    //do stuff
  } else {
    //how do I know if everything is fine?
    
    switch(errno){
    // 
    }
  }
  return 0;
}
	\end{minted}
\end{frame}


\begin{frame}[fragile]{Error code - better approach}
	\begin{minted}{c++}
// declaration
int sqlite3_open( const char *filename,
                  sqlite3 **ppDb /* OUT: SQLite db handle */);
	
//usage
int open_status = sqlite3_open(/* ... */);
if(open_status == SQLITE_OK){
  // make use of opened database
} else if( open_status == SQLITE_CANTOPEN_ISDIR ) {
  // handle the error
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{C++11: yet another approach to the error codes }
	There are 3 types, that C++ 11 added to support \texttt{std::error\_code}
	
	\vskip 1em
	
	\begin{itemize}
		\item \href{https://en.cppreference.com/w/cpp/error/error_code}{\color{blue}\texttt{std::error\_code}}
		\item \href{https://en.cppreference.com/w/cpp/error/error_condition
			}{\color{blue}\texttt{std::error\_condition}}
		\item \href{https://en.cppreference.com/w/cpp/error/error_category}{\color{blue}\texttt{std::error\_category}}
	\end{itemize}
	
\end{frame}

\begin{frame}{\texttt{std::error\_code}}
\end{frame}

\begin{frame}{\texttt{std::error\_condition}}
	
\end{frame}

\begin{frame}{\texttt{std::error\_category}}
\end{frame}

\begin{frame}{\texttt{std::error\_code in action}}
\end{frame}

\subsection{Exceptions}
\begin{frame}[fragile]{Exceptions}
	And so there are also exceptions.
	
	\vskip 1em
	How could things look like with exceptions:
	\vskip 1em
	
	\begin{minted}{c++}
#include <stdio.h>
int main ()
{
  try {
    FILE pFile = fopen ("myfile.txt","w");
    //stuff here
  }
  catch(std::exception& e){
    //handle error
  }
  //so stuff
  return 0;
}
	\end{minted}
	
\end{frame}

\begin{frame}{exceptions implementation}
	We can divide implementation of exceptions into 2 types:
	\begin{itemize}
		\item table-based implementation
		\item frame based implementation
	\end{itemize}
\end{frame}

\begin{frame}{table based exceptions}
	
\end{frame}

\begin{frame}{frame based exceptions}
	
\end{frame}

\begin{frame}{"You don't pay for what you don't use"}
\end{frame}

\begin{frame}[fragile]{Let's stick to error codes or provide dual API}
	People from standardization commitee tried to do that and failed :)
	
	\vskip 2em
	
	Example of such failure can be functions from filesystem library
	
	\vskip 2em
	
	\begin{minted}{c++}
directory_iterator& operator++();
directory_iterator& increment( std::error_code& ec );
	\end{minted}
	
	\vskip 2em 
	
	The increment function even though is meant to return errors through
	\texttt{std::error\_code} can return some of the errors through exceptions.
	
\end{frame}

\begin{frame}[fragile]{Error codes continued}
	\begin{minted}{c++}
A::A(){ 	// a constructor here
  /* some initialization happening */
  /* but whoops an error occurs, what now?*/
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Error codes continued}

	\begin{columns}
		\begin{column}{0.48\linewidth}
			\begin{minted}{c++}
A::A(){  //a constructor here
  /* some initialization*/
  /* but whoops an error occurs */

  throw error; 
}
			\end{minted}
		\end{column}
	\pause
		\begin{column}{0.48\linewidth}
			\begin{minted}{c++}
A::A(){  //a constructor here
  /* some initialization */
  /* but whoops an error occurs */
}	

bool A::IsValid(){ 
  // was init successful?
} 
	
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}
	
\begin{frame}{Current exception handling summary}
	\centering

	\begin{figure}
	
		\resizebox{0.9\linewidth}{!}{%
			\begin{tabular}{c||c|c}
				feature & exceptions & error codes \\ \hline \hline
				constructors usability & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				concise code & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				performance & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				binary size & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				safety & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
			\end{tabular}
		}
		\caption{comparison of error handling mechanisms' capabilities}	
	\end{figure}
	

\end{frame}
	
\section{Perfect error handling}

\begin{frame}{Quality factors of error handling}
\end{frame}

\begin{frame}{error codes - quality}
\end{frame}

\begin{frame}{exception - quality}
\end{frame}

\begin{frame}{error codes vs exceptions}	
\end{frame}

\section{Improving error handling mechanisms}
	
\begin{frame}{Other languages' error handling mechanisms}
\end{frame}

\begin{frame}{C++ strongest attitude - type system}
\end{frame}

\begin{frame}{Implementing our own error handling mechanism}
\end{frame}
	
\begin{frame}{our error handling vs exceptions vs error codes}
\end{frame}
	
\section{Type system related error handling improvements}

\subsection{std::expected}
\begin{frame}{Introducing expected}
\end{frame}

\begin{frame}{Usage}
\end{frame}

\begin{frame}{Implementation details}
\end{frame}

\begin{frame}{Runtime performance}
\end{frame}

\subsection{std::outcome}

\begin{frame}{Introducing outcome}
\end{frame}

\begin{frame}{Implementation details}
\end{frame}

\begin{frame}{Runtime performance}
\end{frame}



\section{Embedding new error handling into the language}
\begin{frame}{New exception model - idea}d
	\begin{center}
		Let's recall the comparison of exceptions and error codes:
	\end{center}
	
	\begin{figure}
		\resizebox{0.9\linewidth}{!}{%
			\begin{tabular}{c||c|c}
				feature & exceptions & error codes \\ \hline \hline
				constructors usability & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				concise code & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				performance & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				binary size & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				safety & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
			\end{tabular}
		}
	\end{figure}
	
\end{frame}

\begin{frame}{Learning from mistakes}
	\centering
	Conclusion:
	
	\begin{itemize}
		\item exceptions gives nice code
		\item error codes provides performance and reliability
	\end{itemize}

	\begin{alertblock}{Next step:}
	Let's use exception syntax for error codes-like handling.
	\end{alertblock}
	
\end{frame}
	
\begin{frame}{\texttt{std::error}}
	features of \texttt{std::error} includes:
	\begin{itemize}
		\item trivially-relocatable semantics
		\item size of max 2 pointers
		\begin{itemize}
			\item 
		\end{itemize}
	\end{itemize}
\end{frame}
	
	
\subsection{How can new exception handling look like}
\begin{frame}[fragile]{Syntax for new exceptions}
	\begin{itemize}
		\item Let's take legacy exception specifications (\texttt{throws(typeid ...)})
		\item Let's declare a function, that throws exceptions:
		\begin{minted}{c++}
void foo() throws(std::bad_alloc);
		\end{minted}
		\item Let \texttt{throws()} modify the return channel of a function
		\item now compiler knows, what kind of exceptions can be thrown.
		\item exceptions now are {\color{red}copied} to the callee.
	\end{itemize}
\end{frame}

\begin{frame}{static exceptions specification}
	
\end{frame}
	
\end{document}