\documentclass[10pt]{beamer}

\usetheme[progressbar=frametitle]{metropolis}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\usepackage{minted}

\usepackage{pgfplots}

\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}

\title{Futuristic Error Handling}
\subtitle{Error handling in C++ today and tomorrow}
\logo{\includegraphics[width=0.05\linewidth]{logo.png}}
% \date{\today}
\date{}
\author{Dawid Pilarski}
\institute{dawid.pilarski@panicsofware.com}

\begin{document}

\maketitle

%\begin{frame}{Table of contents}
%  \setbeamertemplate{section in toc}[sections numbered]
%  \tableofcontents[hideallsubsections]
%\end{frame}

\section{Introduction}

\begin{frame}{Why am I here?}
	Why should we bother with error handling?

\begin{frame}
	\tableofcontents
\end{frame}


\begin{frame}{Recommendable error handling mechanism}
	Which error mechanism would you choose?
	
	There exist two common strategies for error handling:
	\begin{itemize}
		\item error codes?
		\item exceptions?
	\end{itemize}
\end{frame}

\section{Error codes nowadays}
\begin{frame}{The error codes.}
	\begin{itemize}[<+- | alert@+>]
		\item Old. C-compatible. Comes from assembly time.
		\item Machine friendly.
		\item Super fast.
		\item Used till today.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Error code example}
	\begin{minted}{c++}
int sqlite3_open( const char *filename, sqlite3 **ppDb );
	\end{minted}
	
	\pause
	
	\hrulefill
	
	\begin{minted}{c++}
int open_status = sqlite3_open(/* ... */ );
if(open_status == SQLITE_OK){
  // make use of opened database
} else if( open_status == SQLITE_CANTOPEN_ISDIR ) {
  // handle the error
}
	\end{minted}
	
\end{frame}

\begin{frame}{Handle the error}
	How to handle the error correctly?
	
	\pause
	
	\begin{itemize}[<+- | alert@+>]
		\item \texttt{std::terminate()}
		\item take the error callback
		\item propagate the error to the caller
	\end{itemize}
	
\end{frame}

\section{Error codes - propagation}

\begin{frame}[fragile]{propagation}
	\begin{minted}{c++}
void foo_bar(int& errc /*...*/){
  errc = foo();
  // ...
  errc = bar();		
  // ...
}
	\end{minted}
	
\end{frame}

\begin{frame}[fragile]{error translation}
	\begin{minted}{c++}
void foo_bar(foo_bar_errc errc&){
  foo_errc ferrc = foo();
  errc = translate_foo(ferrc);
  // ...
  bar_errc berrc = bar();
  errc = translate_foo(berrc);
}
	\end{minted}
\end{frame}

\begin{frame}{C-style error codes summary}
	So we can see {\color{red}serious disadvantages} (except for {\color{blue}obvious advantages}):
	
	\begin{itemize}[<+- | alert@+>]
		\item success path same as error path
		\item boiler plate code
		\item cluttering code with translations
	\end{itemize}
\end{frame}
	
\begin{frame}{Current exception handling summary}
	\centering

\section{Error codes - modern approach}
\begin{frame}{standard library support - what do we need?}
	\begin{itemize}
		\item A way to define new error codes
		\item A way to distinguish domain of the error codes
		\item And to fix as many C-style issues as possible
	\end{itemize}
\end{frame}
	
\section{Perfect error handling}

\begin{frame}{Standard library support - what we get?}
	three types:
	\begin{itemize}
		\item \texttt{std::error\_code}
		\item \texttt{std::error\_category}
		\item \texttt{std::error\_condition}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{std::error\_code in action}
	\begin{minted}{c++}
std::error_code errc;

is_regular_file("non_existent_directory", errc);

std::cout << errc << std::endl;
std::cout << errc.value() << std::endl;
std::cout << errc.message() << std::endl;
std::cout << errc.category().name() << std::endl;
	\end{minted}
	
	\hrulefill
	
	\texttt{\\
		\$ system:2 \\
		\$ 2 \\
		\$ Nie można odnalexć określonego pliku. \\
		\$ system}
\end{frame}
	
\section{Type system related error handling improvements}

\subsection{std::expected}
\begin{frame}{Introducing expected}
\end{frame}

\begin{frame}{Usage}
\end{frame}

\end{document}

\begin{frame}{Runtime performance}
\end{frame}

\subsection{std::outcome}

\begin{frame}{Introducing outcome}
\end{frame}

\begin{frame}{Implementation details}
\end{frame}

\begin{frame}{Runtime performance}
\end{frame}



\section{Embedding new error handling into the language}
\begin{frame}{New exception model - idea}d
	\begin{center}
		Let's recall the comparison of exceptions and error codes:
	\end{center}
	
	\begin{figure}
		\resizebox{0.9\linewidth}{!}{%
			\begin{tabular}{c||c|c}
				feature & exceptions & error codes \\ \hline \hline
				constructors usability & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				concise code & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				performance & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				binary size & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				safety & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
			\end{tabular}
		}
	\end{figure}
	
\end{frame}

\begin{frame}{Learning from mistakes}
	\centering
	Conclusion:
	
	\begin{itemize}
		\item exceptions gives nice code
		\item error codes provides performance and reliability
	\end{itemize}

	\begin{alertblock}{Next step:}
	Let's use exception syntax for error codes-like handling.
	\end{alertblock}
	
\end{frame}
	
\begin{frame}{\texttt{std::error}}
	features of \texttt{std::error} includes:
	\begin{itemize}
		\item trivially-relocatable semantics
		\item size of max 2 pointers
		\begin{itemize}
			\item 
		\end{itemize}
	\end{itemize}
\end{frame}
	
	
\subsection{How can new exception handling look like}
\begin{frame}[fragile]{Syntax for new exceptions}
	\begin{itemize}
		\item Let's take legacy exception specifications (\texttt{throws(typeid ...)})
		\item Let's declare a function, that throws exceptions:
		\begin{minted}{c++}
void foo() throws(std::bad_alloc);
		\end{minted}
		\item Let \texttt{throws()} modify the return channel of a function
		\item now compiler knows, what kind of exceptions can be thrown.
		\item exceptions now are {\color{red}copied} to the callee.
	\end{itemize}
\end{frame}

\begin{frame}{static exceptions specification}
	
\end{frame}
	
\end{document}