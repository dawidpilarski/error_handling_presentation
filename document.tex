\documentclass[10pt]{beamer}

\usetheme[progressbar=frametitle, block=fill]{metropolis}

\definecolor{amethyst}{rgb}{0.8, 0.6, 1.0}
\definecolor{amethystdark}{rgb}{0.2, 0.1, 0.4}

%\setbeamercolor{title}{fg=amethyst, bg=amethyst}
\setbeamercolor{frametitle}{bg=amethystdark}
%\setbeamercolor{structure}{fg=amethyst}
%\setbeamercolor{progress bar}{ ... }
%\setbeamercolor{title separator}{ ... }
%\setbeamercolor{progress bar in head/foot}{ ... }
%\setbeamercolor{progress bar in section page}{ ... }

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\usepackage{minted}

\usepackage{pgfplots}

\usepackage{xspace}

\title{Futuristic Error Handling}
\subtitle{Error handling in C++ today and tomorrow}
%\logo{\includegraphics[width=0.05\linewidth]{logo.png}}
% \date{\today}
\date{}
\author{Dawid Pilarski}
\institute{dawid.pilarski@panicsofware.com}

\begin{document}

\maketitle

%\begin{frame}{Table of contents}
%  \setbeamertemplate{section in toc}[sections numbered]
%  \tableofcontents[hideallsubsections]
%\end{frame}

\section{Introduction}

\begin{frame}{Why am I here?}
	Why should we bother with error handling?
\end{frame}

\begin{frame}{Recommendable error handling mechanism}
	Which error mechanism would you choose?
	
	There exist two common strategies for error handling:
	\begin{itemize}
		\item error codes?
		\item exceptions?
	\end{itemize}
\end{frame}

\section{Error codes nowadays}
\begin{frame}{The error codes.}
	\begin{itemize}[<+- | alert@+>]
		\item Old. C-compatible. Comes from assembly time.
		\item Machine friendly.
		\item Super fast.
		\item Used till today.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Error code example}
	\begin{minted}{c++}
int sqlite3_open( const char *filename, sqlite3 **ppDb );
	\end{minted}
	
	\pause
	
	\hrulefill
	
	\begin{minted}{c++}
int open_status = sqlite3_open(/* ... */ );
if(open_status == SQLITE_OK){
  // make use of opened database
} else if( open_status == SQLITE_CANTOPEN_ISDIR ) {
  // handle the error
}
	\end{minted}
	
\end{frame}

\begin{frame}{Handle the error}
	How to handle the error correctly?
	
	\pause
	
	\begin{itemize}[<+- | alert@+>]
		\item \texttt{std::terminate()}
		\item take the error callback
		\item propagate the error to the caller
	\end{itemize}
	
\end{frame}

\section{Error codes - propagation}

\begin{frame}[fragile]{propagation}
	\begin{minted}{c++}
void foo_bar(int& errc /*...*/){
  errc = foo();
  // ...
  errc = bar();		
  // ...
}
	\end{minted}
	
\end{frame}

\begin{frame}[fragile]{error translation}
	\begin{minted}{c++}
void foo_bar(foo_bar_errc errc&){
  foo_errc ferrc = foo();
  errc = translate_foo(ferrc);
  // ...
  bar_errc berrc = bar();
  errc = translate_foo(berrc);
}
	\end{minted}
\end{frame}

\begin{frame}{C-style error codes summary}
	So we can see {\color{red}serious disadvantages} (except for {\color{blue}obvious advantages}):
	
	\begin{itemize}[<+- | alert@+>]
		\item success path same as error path
		\item boiler plate code
		\item cluttering code with translations
	\end{itemize}
\end{frame}
	

\section{Error codes - modern approach}
\begin{frame}{standard library support - what do we need?}
	\begin{itemize}
		\item A way to define new error codes
		\item A way to distinguish domain of the error codes
		\item And to fix as many C-style issues as possible
	\end{itemize}
\end{frame}

\begin{frame}{standard library support - what we get?}
	We get three new major types:
	\begin{itemize}
		\item std::error\_code
		\item std::error\_category
		\item std::error\_condition
	\end{itemize}
\end{frame}
	

\begin{frame}[fragile]{std::error\_code in action}
	\begin{minted}{c++}
std::error_code errcode;
is_regular_file("non_existent_directory", errcode);

std::cout << errcode << std::endl;
std::cout << errcode.value() << std::endl;
std::cout << errcode.message() << std::endl;
std::cout << errcode.category().name() << std::endl;
	\end{minted}
	
	\hrulefill
	
	\begin{block}{output}
	\texttt{\\
		\$ generic:2 \\
		\$ 2 \\
		\$ No such file or directory \\
		\$ generic}	
	\end{block}
	
\end{frame}

\begin{frame}[fragile]{Acting upon error}
	\begin{minted}{c++}
std::error_code errcode;
is_regular_file("non_existent_file", errcode);
  
if(errcode == errc::no_such_file_or_directory){
  // creating a file
}
	\end{minted}
\end{frame}

\begin{frame}{Let's define our own error code}
	Steps to create own error code:
	\begin{itemize}[<+- | alert@+>]
		\item define custom enum with error codes
		\item inform, that the enum is an error code
		\item create custom error category (or use existing one)
		\item create enum to error code factory function
		\item (optional) define custom error condition
		\begin{itemize}
			\item define error condition enum
			\item inform the world about new error condition enum
			\item make conversion function from new error code to error condition
		\end{itemize}
		\item enjoy!
	\end{itemize}
\end{frame}

\section{Error codes - \\ defining custom error codes}

\begin{frame}{Step 1 - define custom enum with error codes}
	
\end{frame}

\begin{frame}{Step 2 - inform the world about new error code type}

\end{frame}

\begin{frame}{Step 3 - custom error category}

\end{frame}

\begin{frame}{Step 4 - factory function}
	
\end{frame}

\begin{frame}{Step 5 - custom error condition}
	
\end{frame}

\begin{frame}{Step 6 - Enjoy}
	
\end{frame}

\begin{frame}{More complex example}
	
\end{frame}
	
\section{Error codes - summary}


\section{Exceptions to the rescue (?)}
	
\end{document}