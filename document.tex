\documentclass[10pt,a4paper]{beamer}
\usetheme{Copenhagen}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{pifont}
\usepackage[cache=false]{minted}

\setminted{fontsize=\footnotesize}

\date{}
\author{Dawid Pilarski}

\title{Error handling in C++}
\subtitle{\href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r1.pdf}{p0709r1} , \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf}{p0323r3}}

\AtBeginSection[]
{
	\begin{frame}<beamer>
	\frametitle{Plan}
	\tableofcontents[currentsection]
\end{frame}
}

\begin{document}


\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\tableofcontents
\end{frame}

\section{Current state of error handling}
\begin{frame}{Error handling and performance}
	
	There exist two common strategies for error handling:
	\begin{itemize}
		\item error codes
		\item exceptions
	\end{itemize}

\end{frame}

\subsection{Error codes}
\begin{frame}[fragile]{Error codes - example fopen}
	\begin{minted}{c++}
/* fopen example */
#include <stdio.h>
int main ()
{
  FILE * pFile;
  pFile = fopen ("myfile.txt","w");
  if (pFile!=NULL)
  {
    //do stuff
  } else {
    //how do I know if everything is fine?
    
    switch(errno){
    // 
    }
  }
  return 0;
}
	\end{minted}
\end{frame}


\begin{frame}[fragile]{Error code - better approach}
	\begin{minted}{c++}
// declaration
int sqlite3_open( const char *filename,
                  sqlite3 **ppDb /* OUT: SQLite db handle */);
	
//usage
int open_status = sqlite3_open(/* ... */);
if(open_status == SQLITE_OK){
  // make use of opened database
} else if( open_status == SQLITE_CANTOPEN_ISDIR ) {
  // handle the error
}
	\end{minted}


	\begin{block}{further improvements:}
		\begin{itemize}
			\item enums
			\item error code taken as reference
		\end{itemize}	
	\end{block}
\end{frame}

\begin{frame}[fragile]{C++ 11 approach to the error codes }
	There are 3 types, that C++ 11 added to support error codes.
	
	\vskip 1em
	
	\begin{itemize}
		\item \href{https://en.cppreference.com/w/cpp/error/error_code}{\color{blue}\texttt{std::error\_code}}
		\item \href{https://en.cppreference.com/w/cpp/error/error_condition
			}{\color{blue}\texttt{std::error\_condition}}
		\item \href{https://en.cppreference.com/w/cpp/error/error_category}{\color{blue}\texttt{std::error\_category}}
	\end{itemize}
	
\end{frame}

\subsection{Exceptions}
\begin{frame}[fragile]{But don't forget about exceptions}
	And so there are also exceptions.
	
	\vskip 1em
	How could things look like with exceptions:
	\vskip 1em
	
	\begin{minted}{c++}
#include <stdio.h>
int main ()
{
  try {
    FILE* pFile = fopen ("myfile.txt","w");
    //stuff here
  }
  catch(std::exception& e){
    //handle error
  }
  return 0;
}
	\end{minted}
	
\end{frame}

\begin{frame}{"types" of exceptions}
	We can divide implementation of exceptions into 2 types:
	\begin{itemize}
		\item table-based implementation
		\item frame based implementation
	\end{itemize}
\end{frame}

\begin{frame}{"You don't pay for what you don't use"}
	\begin{block}{table based exceptions}
		optimized for scenarios when usually exceptions are not throwed
	\end{block}

	\begin{block}{frame based exception}
		optimized for scenarios when exceptions are thrown often
	\end{block}

	\begin{block}{binary size}
		no matter which implementation is chosen the binary size grows
		significantly even when exceptions are not used.
	\end{block}

\end{frame}

\begin{frame}[fragile]{Let's stick to error codes or provide dual API}
	People from standardization commitee tried to do that and failed :)
	
	\vskip 2em
	
	Example of such failure can be functions from filesystem library
	
	\vskip 2em
	
	\begin{minted}{c++}
directory_iterator& operator++();
directory_iterator& increment( std::error_code& ec );
	\end{minted}
	
	\vskip 2em 
	
	\pause
	
	The increment function even though is meant to return errors through
	\texttt{std::error\_code} can return some of the errors through exceptions.
	
\end{frame}

\begin{frame}[fragile]{Error codes continued}
	\begin{minted}{c++}
A::A(){ 	// a constructor here
  /* some initialization happening */
  /* but whoops an error occurs, what now?*/
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Error codes continued}

	\begin{columns}
		\begin{column}{0.48\linewidth}
			\begin{minted}{c++}
A::A(){  //a constructor here
  /* some initialization*/
  /* but whoops an error occurs */

  throw error; 
}
			\end{minted}
		\end{column}
	\pause
		\begin{column}{0.48\linewidth}
			\begin{minted}{c++}
A::A(){  //a constructor here
  /* some initialization */
  /* but whoops an error occurs */
}	

bool A::IsValid(){ 
  // was init successful?
} 
	
			\end{minted}
		\end{column}
	\end{columns}
\end{frame}
	
\begin{frame}{Current exception handling summary}
	\centering

	\begin{figure}
	
		\resizebox{0.9\linewidth}{!}{%
			\begin{tabular}{c||c|c}
				feature & exceptions & error codes \\ \hline \hline
				constructors usability & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				concise code & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				performance & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				binary size & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				safety & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
			\end{tabular}
		}
		\caption{comparison of error handling mechanisms' capabilities}	
	\end{figure}
	

\end{frame}

\section{\texttt{std::expected}}
\begin{frame}[fragile]{further with error codes}
\begin{block}{Idea}
	Let's embed the return error code with expected type
\end{block}

\vfill

\begin{minted}{c++}
template <typename T, typename E>
class expected;
\end{minted}
\end{frame}



\begin{frame}[fragile]{Usage example}

\begin{columns}
\begin{column}{0.48\linewidth}
	\begin{minted}{c++}
enum class arithmetic_errc {
  divide_by_zero,
  not_integer_division,      
  integer_divide_overflows
};
	\end{minted}
\end{column}
\pause
\begin{column}{0.48\linewidth}
	\begin{minted}{c++}
using errc = arithmetic_errc;
expected<double, errc>
safe_divide(double i, double j){
  if(j==0){ 
    return 
    unexpected(errc::divide_by_zero);
  } else 
    return i/j;
}
	\end{minted}
\end{column}
\end{columns}
\end{frame}

\section{New exception model}
\begin{frame}{New exception model - idea}
	\begin{center}
		Let's recall the comparison of exceptions and error codes:
	\end{center}
	
	\begin{figure}
		\resizebox{0.9\linewidth}{!}{%
			\begin{tabular}{c||c|c}
				feature & exceptions & error codes \\ \hline \hline
				constructors usability & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				concise code & \cellcolor{green}\checkmark & \cellcolor{red}\ding{56} \\ \hline
				performance & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				binary size & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
				safety & \cellcolor{red}\ding{56} & \cellcolor{green}\checkmark \\ \hline
			\end{tabular}
		}
	\end{figure}
	
\end{frame}

\begin{frame}{Learning from mistakes}
	\centering
	Conclusion:
	
	\begin{itemize}
		\item exceptions gives nice code
		\item error codes provides performance and reliability
	\end{itemize}

	\begin{alertblock}{Next step:}
	Let's use exception syntax for error codes-like handling.
	\end{alertblock}
	
\end{frame}

\begin{frame}{Idea}

	\begin{alertblock}{using return channel}
		Let's make throwing exceptions happen using return channels from functions
	\end{alertblock}
\end{frame}

\begin{frame}{using return channel}
	How to achieve that:
	\begin{itemize}
		\item Function needs to return some kind of a \texttt{std::variant<T, E>}
		\item The \texttt{sizeof(E)} in above needs to be known upfront
		\item Each exception must have same interface
		\item Compiler must know how to \texttt{move} the object
	\end{itemize}
	
	Other things to consider:
	\begin{itemize}
		\item co-existence with dynamic exceptions
	\end{itemize}
\end{frame}
	
\begin{frame}{\texttt{std::error}}
	features of \texttt{std::error} includes:
	\begin{itemize}
		\item trivially-relocatable semantics
		\item the \texttt{error\_category} is able to represent:
		\begin{itemize}
			\item C++ standard library exceptions
			\item POSIX system codes
			\item Windows' \texttt{NSTATUS}
			\item and other common error domains
		\end{itemize}
	\end{itemize}

	\vfill

	\texttt{std::error} type can be treated as a next-gen \texttt{std::error\_code} type.
\end{frame}
	
	
\subsection{How can new exception handling look like}

	
\begin{frame}[fragile]{The forgotten \texttt{throws}}
	
	Since we no longer need to know the type of the exception,
	we can notify about function throwing the static exception with \texttt{throws}
	static exception specifier
	
	\begin{minted}{c++}
void foo() throws {
  throw arithmetic_error::something;
}
	\end{minted}
	
\end{frame}

\begin{frame}[fragile]{more examples}

	\begin{minted}{c++}
string foo() throws {
  //dynamic exception will be translated to static one
  throw std::runtime_error; 
}
	\end{minted}
	
	\hfill
	
	\begin{minted}{c++}
try {
  auto result = g();
  cout << "success, result is: " << result;
}
catch(error err) { // catch by value is fine
  cout << "failed, error is: " << err.error();
}
	\end{minted}
	
	
\end{frame}

\begin{frame}[fragile]{more examples}
	\begin{minted}{c++}
int caller2(int i, int j) {
  try {
    return safe_divide(i, j);
  } catch(error e) {
    if (e == arithmetic_errc::divide_by_zero)
      return 0;
    if (e == arithmetic_errc::not_integer_division)
      return i / j; // ignore
    if (e == arithmetic_errc::integer_divide_overflows)
      return INT_MIN;
  }
}
	\end{minted}
	
\end{frame}



\begin{frame}{The END}
\centering
	Thanks for attention!
\end{frame}
	
\end{document}