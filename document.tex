\documentclass[10pt]{beamer}

\usetheme[progressbar=frametitle]{metropolis}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\usepackage{minted}

\usepackage{pgfplots}

\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}

\title{Futuristic Error Handling}
\subtitle{Error handling in C++ today and tomorrow}
\logo{\includegraphics[width=0.05\linewidth]{logo.png}}
% \date{\today}
\date{}
\author{Dawid Pilarski}
\institute{dawid.pilarski@panicsofware.com}

\begin{document}

\maketitle

%\begin{frame}{Table of contents}
%  \setbeamertemplate{section in toc}[sections numbered]
%  \tableofcontents[hideallsubsections]
%\end{frame}

\section{Introduction}

\begin{frame}{Why am I here?}
	Why should we bother with error handling?

\end{frame}


\begin{frame}{Recommendable error handling mechanism}
	Which error mechanism would you choose?
	
	\begin{itemize}
		\item error codes?
		\item exceptions?
	\end{itemize}
\end{frame}

\section{Error codes nowadays}
\begin{frame}{The error codes.}
	\begin{itemize}[<+- | alert@+>]
		\item Old. C-compatible. Comes from assembly time.
		\item Machine friendly.
		\item Super fast.
		\item Used till today.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Error code example}
	\begin{minted}{c++}
int sqlite3_open( const char *filename, sqlite3 **ppDb );
	\end{minted}
	
	\pause
	
	\hrulefill
	
	\begin{minted}{c++}
int open_status = sqlite3_open(/* ... */ );
if(open_status == SQLITE_OK){
  // make use of opened database
} else if( open_status == SQLITE_CANTOPEN_ISDIR ) {
  // handle the error
}
	\end{minted}
	
\end{frame}

\begin{frame}{Handle the error}
	How to handle the error correctly?
	
	\pause
	
	\begin{itemize}[<+- | alert@+>]
		\item \texttt{std::terminate()}
		\item take the error callback
		\item propagate the error to the caller
	\end{itemize}
	
\end{frame}

\section{Error codes - propagation}

\begin{frame}[fragile]{propagation}
	\begin{minted}{c++}
void foo_bar(int& errc /*...*/){
  errc = foo();
  // ...
  errc = bar();		
  // ...
}
	\end{minted}
\end{frame}

\begin{frame}[fragile]{error translation}
	\begin{minted}{c++}
void foo_bar(foo_bar_errc errc&){
  foo_errc ferrc = foo();
  errc = translate_foo(ferrc);
  // ...
  bar_errc berrc = bar();
  errc = translate_foo(berrc);
}
	\end{minted}
\end{frame}

\begin{frame}{C-style error codes summary}
	So we can see {\color{red}serious disadvantages} (except for {\color{blue}obvious advantages}):
	
	\begin{itemize}[<+- | alert@+>]
		\item success path same as error path
		\item boiler plate code
		\item cluttering code with translations
	\end{itemize}
\end{frame}

\section{Error codes - modern approach}
\begin{frame}{standard library support - what do we need?}
	\begin{itemize}
		\item A way to define new error codes
		\item A way to distinguish domain of the error codes
		\item And to fix as many C-style issues as possible
	\end{itemize}
\end{frame}

\begin{frame}{Standard library support - what we get?}
	three types:
	\begin{itemize}
		\item \texttt{std::error\_code}
		\item \texttt{std::error\_category}
		\item \texttt{std::error\_condition}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{std::error\_code in action}
	\begin{minted}{c++}
std::error_code errc;

is_regular_file("non_existent_directory", errc);

std::cout << errc << std::endl;
std::cout << errc.value() << std::endl;
std::cout << errc.message() << std::endl;
std::cout << errc.category().name() << std::endl;
	\end{minted}
	
	\hrulefill
	
	\texttt{\\
		\$ system:2 \\
		\$ 2 \\
		\$ Nie można odnalexć określonego pliku. \\
		\$ system}
\end{frame}



\end{document}
